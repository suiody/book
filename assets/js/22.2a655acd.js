(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{106:function(e,n,r){"use strict";r.r(n);var t=[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"populare-blockchain-plattformen"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#populare-blockchain-plattformen","aria-hidden":"true"}},[e._v("#")]),e._v(" Populäre Blockchain Plattformen")]),t("h2",{attrs:{id:"bitcoin"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bitcoin","aria-hidden":"true"}},[e._v("#")]),e._v(" Bitcoin")]),t("p",[e._v("Autor: Nils Dralle")]),t("p",[e._v("Bitcoin ist eine sogenannte Kryptowährung, die ohne eine zentrale Kontrollinstanz (wie z.b. eine Bank) auskommt. Stattdessen bilden alle, die am Zahlungsverkehr mit Bitcoin teilnehmen wollen, ein Netzwerk von Knoten, eine sogenannte Blockchain. Die Bitcoin-Blockchain fungiert als Kontrollinstanz. In ihr werden alle Transaktionen mit Bitcoins vermerkt, und alle Teilnehmer des Netzwerks sind gemeinsam dafür verantwortlich, dass die zugrunde liegende Blockchain aktuell und konsistent ist. Um eine Überweisung mit Bitcoins vornehmen zu können, müssen Sender und Empfänger eine aktuelle Kopie der Blockchain haben. Jede Transaktion im Bitcoin-Netzwerk wird kryptografisch abgesichert.")]),t("h3",{attrs:{id:"geschichte-des-bitcoin"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#geschichte-des-bitcoin","aria-hidden":"true"}},[e._v("#")]),e._v(' "Geschichte" des Bitcoin')]),t("p",[e._v("Das Bitcoin-Netzwerk wurde im Jahr 2008 erstmals theoretisch unter dem Pseudonym Satoshi Nakamoto beschrieben und 2009 praktisch umgesetzt. Das Konzept kryptografischer Währungen wurde bereits 1998 veröffentlicht. Auch wenn der Bitcoin als Währung gedacht ist, so ist er in den letzten Jahren immer mehr zum Investitions- und Spekulationsobjekt geworden. Der Bitcoin-Wechselkurs erreichte Ende 2017 sein bisheriges Maximum von circa 16.000€ pro Bitcoin und steht derzeit (wenige Monate später) bei 7500€ pro Bitcoin.")]),t("h3",{attrs:{id:"bootstrapping"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bootstrapping","aria-hidden":"true"}},[e._v("#")]),e._v(" Bootstrapping")]),t("p",[e._v('Um sich initial mit anderen Knoten zu verbinden, nutzt der Bitcoin einen sogenannten "Bootstrapping"-Prozess. Mehrere Knoten des Netzwerks fungieren als Startknoten, die die Adressen weiterer Knoten an neue Knoten verteilen. Die Adressen der Startknoten sind im Domain-Name-System eingetragen, welches der Bitcoin-Client nutzt, um die Adressen der Startknoten zu erhalten. Nachdem die initiale Verbindung erfolgt ist und die Adressen weiterer Knoten von den Startknoten weitergegeben wurden, kommt das Bitcoin-Netzwerk auch ohne die Startknoten aus.')]),t("h3",{attrs:{id:"blocke"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#blocke","aria-hidden":"true"}},[e._v("#")]),e._v(" Blöcke")]),t("p",[e._v('Die Bitcoin-Blockchain ist aus 1 Megabyte großen Blöcken aufgebaut. Jeder Block kann mehrere Transaktionen beinhalten. Neue Blöcke werden mittels "Mining" erzeugt. Bei der Erzeugung von neuen Blöcken wird ein Algorithmus mit anpassbarer Schwierigkeit verwendet, so dass ein neuer Block etwa alle 10 Minuten erzeugt wird.\nJeder Block in der Blockchain verweist auf den vorherigen Block mit dem Hashwert des vorherigen Blockes. Eine Manipulation eines Blockes vor dem aktuellen ist damit nicht möglich. Eine Sonderstellung nimmt der sogenannte Genesis-Block (der erste Block) ein: Dieser hat keinen Vorgänger und wurde nicht von der Blockchain berechnet. Beim Bitcoin ist der Genesis-Block zudem im Quellcode fest integriert.')]),t("h3",{attrs:{id:"transaktionen"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#transaktionen","aria-hidden":"true"}},[e._v("#")]),e._v(" Transaktionen")]),t("p",[e._v("Jede Transaktion im Bitcoin-Netzwerk besteht aus der kryptografischen Signatur des Senders und dem mit dem Public-Key des Empfängers signierten Hash der vorherigen Transaktion. Auf diese Weise kann der Empfänger die Transaktion verifizieren. Transaktionen werden an alle Knoten im Netzwerk verteilt. "),t("a",[t("a",{attrs:{href:"#ref_naka08"}},[e._v("[NAKA08]")])]),e._v(" Jede Transaktion hat beim Bitcoin mehrere In- und Outputs, um die Transaktion in mehrere Teilbeträge zerlegen zu können. Abbildung 8.4.1.1 zeigt den Prozess.")]),t("p",[t("img",{attrs:{src:r(84),alt:"Bitcoin Transaktionen",title:"Bitcoin Transaktionen"}})]),t("p",[e._v("Abbildung 8.4.1.1 - Bitcoin Transaktionen (Quelle: "),t("a",[t("a",{attrs:{href:"#ref_mona15"}},[e._v("[MONA15]")])]),e._v(")")]),t("p",[e._v('Die Outputs einer Transaktion können auch "unspent" sein. Beträge, die "unspent" sind, wurden noch nicht in einer weiteren Transaktion ausgegeben und werden dem Empfänger der Transaktion zugerechnet.\nDas Bitcoin-Netzwerk kann maximal 7 Transaktionen pro Sekunde verarbeiten. Jede Transaktion muss zuerst in einen Block eingefügt und zur Blockchain hinzugefügt werden, bevor sie von anderen Knoten verifiziert (und vom Empfänger verwendet) werden kann.\nJede Transaktion wird mit einer Gebühr belegt. Diese Transaktionsgebühr geht an den "Miner" des Blockes, mit dem diese Transaktion zur Blockchain hinzugefügt wird.')]),t("h3",{attrs:{id:"mining"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mining","aria-hidden":"true"}},[e._v("#")]),e._v(" Mining")]),t("p",[e._v('Die Aufgabe des "Mining" ist es, Transaktionen zu Blöcken zusammenzufügen und in der Blockchain zu veröffentlichen. Dabei wird der "Proof-of-Work" Algorithmus genutzt. Für das erfolgreiche minen neuer Blöcke werden neue Bitcoins an den erfolgreichen Miner vergeben. Über diesen Mechanismus werden neue Bitcoins erzeugt. Die Anzahl an Bitcoins, die mit jedem neuen Block erzeugt werden, halbiert sich alle 210.000 Blöcke.')]),t("h4",{attrs:{id:"proof-of-work"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#proof-of-work","aria-hidden":"true"}},[e._v("#")]),e._v(" Proof-of-Work")]),t("p",[e._v("Der Bitcoin nutzt einen Proof-of-Work Algorithmus zu Entscheidungsfindung über neue Blöcke. Dabei wird innerhalb des neuen Blocks ein spezieller Wert, eine sogenannte "),t("em",[e._v("Nonce")]),e._v(", angelegt. Dieser Wert wird solange erhöht, bis ein Hash für den Block gefunden wird, der mit einer bestimmten Anzahl Nullen beginnt. Über die benötigte Anzahl Nullen kann die Schwierigkeit des Proof-of-Work angepasst werden. Beim Bitcoin wird die Schwierigkeit automatisch so angepasst, dass ein neuer Block etwa alle 10 Minuten gefunden wird.")]),t("h3",{attrs:{id:"zeitstempel"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#zeitstempel","aria-hidden":"true"}},[e._v("#")]),e._v(" Zeitstempel")]),t("p",[e._v("Damit jeder Knoten die Transaktionen zeitlich einordnen kann, implementiert Bitcoin einen verteilten Zeitstempel-Server. "),t("a",[t("a",{attrs:{href:"#ref_naka08"}},[e._v("[NAKA08]")])]),e._v(" Der Zeitstempel besteht aus dem Hashwert der Daten, die einen Zeitstempel erhalten sollen, sowie dem Hashwert des vorherigen Zeitstempels.")]),t("h2",{attrs:{id:"hyperledger"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hyperledger","aria-hidden":"true"}},[e._v("#")]),e._v(" Hyperledger")]),t("p",[e._v("Autor: Cem Basoglu")]),t("p",[e._v("Das in 2016 gegründete Hyperledger Projekt fasst mehrere Frameworks und Tools\nzusammen, die den Einsatz von Distributed Ledger Technologien in Business\nApplikationen ermöglichen sollen "),t("a",[t("a",{attrs:{href:"#ref_cach16"}},[e._v("[CHAC16]")])]),e._v(".\nNeben den von IBM und Intel initial beigesteuerten Distributed Ledger Codebasen,\nFabric und Sawtooth, gehören mittlerweile drei weitere Frameworks und eine Vielzahl\nvon Tools zum Hyperledger Projekt.")]),t("p",[e._v("Im Gegensatz zu anderen populären Blockchain Plattformen, bei dem eine\nKryptowährung im Vordergrund steht, setzen die Frameworks in Hyperledger auf\neinen möglichst modularen Distributed Ledger und überlassen die Implementierung\neiner Währung und Zahlungsabwicklung, der auf dem Framework aufbauend\nApplikation "),t("a",[t("a",{attrs:{href:"#ref_owen17"}},[e._v("[OWEN17]")])]),e._v(".")]),t("h3",{attrs:{id:"frameworks"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#frameworks","aria-hidden":"true"}},[e._v("#")]),e._v(" Frameworks")]),t("p",[e._v("Jedes Framework im Hyperledger Projekt stellt eine eigene Blockchain Plattform\ndar, die sich sowohl konzeptionell als auch von der Codebasis unterscheiden.\nBevor die einzelnen Frameworks in den folgenden Abschnitten im Detail beschrieben\nwerden, bietet nachstehende Übersicht einen Vergleich der jeweiligen Distributed\nLedger Technologien.")]),t("table",[t("thead",[t("tr",[t("th",[e._v("Merkmal")]),t("th",[e._v("Fabric")]),t("th",[e._v("Sawtooth")]),t("th",[e._v("Iroha")]),t("th",[e._v("Indy")]),t("th",[e._v("Burrow")])])]),t("tbody",[t("tr",[t("td",[e._v("Projekt Status")]),t("td",[e._v("Aktiv")]),t("td",[e._v("Aktiv")]),t("td",[e._v("Aktiv")]),t("td",[e._v("Inkubation")]),t("td",[e._v("Inkubation")])]),t("tr",[t("td",[e._v("Berechtigung")]),t("td",[e._v("permissioned")]),t("td",[e._v("permissioned / permissionless")]),t("td",[e._v("permissioned")]),t("td",[e._v("permissioned")]),t("td",[e._v("permissioned")])]),t("tr",[t("td",[e._v("Konsensus")]),t("td",[e._v("SOLO, Kafka, SBFT")]),t("td",[e._v("PoET, RAFT")]),t("td",[e._v("YAC (BFT)")]),t("td",[e._v("RBFT "),t("a",[t("a",{attrs:{href:"#ref_aubl13"}},[e._v("[AUBL13]")])])]),t("td",[e._v("Tendermint")])]),t("tr",[t("td",[e._v("Smart Contract / Business Model")]),t("td",[e._v("ja")]),t("td",[e._v("ja")]),t("td",[e._v("nein")]),t("td",[e._v("nein")]),t("td",[e._v("ja")])]),t("tr",[t("td",[e._v("SDK")]),t("td",[e._v("Go, Node.JS, Java")]),t("td",[e._v("Python, Go, Javascript")]),t("td",[e._v("gRPC API")]),t("td",[e._v("-")]),t("td",[e._v("Solidity")])])])]),t("h4",{attrs:{id:"fabric"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fabric","aria-hidden":"true"}},[e._v("#")]),e._v(" Fabric")]),t("p",[e._v("Hyperledger Fabrik ist ein Distributed Ledger Framework für "),t("em",[e._v("permissioned")]),e._v("\nBlockchains, zum Ausführen von verteilten Applikationen unter der Verwendung\nvon Standard Sprachen wie Go, Java oder Javascript "),t("a",[t("a",{attrs:{href:"#ref_andr18"}},[e._v("[ANDR18]")])]),e._v(".")]),t("p",[e._v("Wie in Abbildung 8.4.2.1 dargestellt, wird das Framework in die Komponenten\nMembership Service Provider, Peer, Ordering Service und Chaincode unterteilt,\nwobei durch den modularen Aufbau die Komponenten beliebig ausgetauscht oder\ndurch eigene Implementierungen ersetzt werden können. Die Kommunikation zwischen\nden Komponenten erfolgt mittels gRPC.")]),t("p",[t("img",{attrs:{src:r(83),alt:"Fabric Architektur",title:"Fabric Architektur"}})]),t("p",[e._v("Abbildung 8.4.2.1 - Fabric Architektur (Quelle: "),t("a",[t("a",{attrs:{href:"#ref_andr18"}},[e._v("[ANDR18]")])]),e._v(")")]),t("h5",{attrs:{id:"membership-service-provider"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#membership-service-provider","aria-hidden":"true"}},[e._v("#")]),e._v(" Membership Service Provider")]),t("p",[e._v("Damit eine Entität, wie z.b. ein Peer oder Client, mit dem Distributed Ledger\ninteragieren kann, muss dieser im System bekannt sein. Dazu wird jeder Entität\nein Zertifikat nach dem X.509 Standard ausgestellt und der "),t("em",[e._v("Public Key")]),e._v(" beim\nMembership Service Provider registriert. Die Zertifikate dienen als Identität\nund werden sowohl für die Signierung von Transaktionen, als auch für die TLS\ngesicherte Kommunikation zwischen der Peers verwendet.")]),t("p",[e._v("Der MSP kann zentral oder, wenn es das Geschäftsmodell voraussetzt, durch\nmehrere Teilnehmer der Blockchain in einem Verbund betrieben werden. Ebenfalls\nlassen sich ein oder mehrere Organisationen und die dazugehörigen Root- bzw.\nIntermediate-Zertifkate beim MSP registrieren. Mittels der organisatorischen\nEinheiten können komplexere Anwendungsfälle konstruiert werden, bei dem z.B.\nmehrere Unternehmen miteinander agieren können, Transaktionen jedoch nur von\nden Unternehmen gelesen werden können, die von der Transaktion tangiert werden.")]),t("p",[t("img",{attrs:{src:r(82),alt:"Organisationen und Channels",title:"Organisationen und Channels"}})]),t("p",[e._v("Abbildung 8.4.2.2 - Organisationen und Channels (Quelle: "),t("a",[t("a",{attrs:{href:"#ref_fabr18"}},[e._v("[FABR18]")])]),e._v(")")]),t("p",[e._v("Darüber hinaus können sogenannte Channels verwendet werden, um das\nBlockhain-Netzwerk noch weiter zu unterteilen. Jedes dieser Sub-Netzwerke\nbesitzt sowohl einen eigenen Kommunikationskanal, als auch einen eigenen\nDistributed Ledger. Wie in Abbildung 8.4.2.2 dargestellt, können somit mehrere\nprivate Ledgers zwischen den Teilnehmern betrieben werden.")]),t("p",[e._v("Um eine für Bitcoin oder Ethereum typische Blockchain Topologie zu\nimplementieren, würde somit nur ein Channel benötigt werden. Alle Peers würden\ndiesen Channel nutzen, um über einen gemeinsamen Distributed Ledger im Konsens\nzu sein.")]),t("h5",{attrs:{id:"peer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#peer","aria-hidden":"true"}},[e._v("#")]),e._v(" Peer")]),t("p",[e._v("Ein Fabric Blockhain-Netzwerk besteht in der Regel aus mehreren Peers. Jeder\nPeer kann an einem oder mehreren Channels teilnehmen, für den jeweils ein\neigener, logisch getrennter Ledger verwaltet und mittels Smart Contracts\nzugegriffen wird. Dazu verbindet sich der Client mit einem Peer und nutzt die\nFunktionen der auf diesem Peer verfügbaren Smart Contracts, um Daten von dem\nLedger abzufragen bzw. zu ändern. Trotz eines gemeinsamen Ledgers je Channel,\nmüssen nicht alle Peers die selben Smart Contracts bereitstellen.")]),t("p",[e._v("Für die Persistierung des Ledgers wird standardmäßig LevelDB verwendet, um den\nZustand der Smart Contracts als Schlüsselwertepaar abzulegen. Alternativ kann\nauch CouchDB eingesetzt werden, um Datenstrukturen im JSON-Format zu\npersistieren und damit komplexere Abfragen aus dem Ledger zu ermöglichen.")]),t("h5",{attrs:{id:"ordering-service"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ordering-service","aria-hidden":"true"}},[e._v("#")]),e._v(" Ordering Service")]),t("p",[e._v("Während eine Abfrage vom Distributed Ledger von einem einzelnen Peer verarbeitet\nwerden kann, müssen bei Änderungen die Peers im Konsens sein. In diesem Prozess\nnimmt der Ordering Service eine essenzielle Rolle ein. Wie es der Name schon\nerahnen lässt, ist es die Hauptaufgabe des Ordering Service die Transaktionen in\neine Reihenfolge zu bringen, zu einem Block zu verpacken und an die Peers zu\nverteilen. Dadurch wird sichergestellt, dass genug Peers der Änderung zugestimmt\nhaben und alle Transaktionen in der selben Reihenfolge an den Ledger angehängt\nwerden.")]),t("h5",{attrs:{id:"client"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#client","aria-hidden":"true"}},[e._v("#")]),e._v(" Client")]),t("p",[e._v("Wie bei klassischen Client-Server-Architekturen stellt der Client, auch im\nHyperledger Fabric Kontext, die vom Nutzer lokal ausgeführte Applikation dar.\nFür diesen Zweck stellt das Hyperledger Fabric Framework, eine Client-Bibliothek\nbereit, mit dem die Applikation mit den Peers und Ordering Services interagieren\nkann.")]),t("h5",{attrs:{id:"chaincode"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#chaincode","aria-hidden":"true"}},[e._v("#")]),e._v(" Chaincode")]),t("p",[e._v("Ein zentrales Element im Fabric Framework bildet der Smart Contract, der auch\nChaincode genannt wird. Über diesen werden sämtliche Funktionalitäten der\nBlockchain abgebildet. Somit existieren nur zwei Arten von Transaktionen - das\nDeployen eines Smart Contracts und das Aufrufen einer Funktion im Smart\nContract. Über sogenannte System Smart Contracts, die jeder Peer besitzt, können\nebenfalls Konfigurationen am Blockhain Netzwerk vorgenommen werden.")]),t("p",[e._v("Smart Contracts können in Standard Programmiersprachen wie Go, Node.Js oder Java\ngeschrieben werden. Wie in Listing 8.4.2.1 dargestellt, implementiert\njeder Smart Contract das "),t("em",[e._v("ChaincodeInterface")]),e._v(" aus dem Hyperledger Fabric SDK.")]),t("pre",{pre:!0,attrs:{class:"language-javascript"}},[t("code",[t("span",{attrs:{class:"token keyword"}},[e._v("const")]),e._v(" shim "),t("span",{attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{attrs:{class:"token function"}},[e._v("require")]),t("span",{attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{attrs:{class:"token string"}},[e._v("'fabric-shim'")]),t("span",{attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n"),t("span",{attrs:{class:"token keyword"}},[e._v("var")]),e._v(" Chaincode "),t("span",{attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{attrs:{class:"token keyword"}},[e._v("class")]),e._v(" "),t("span",{attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),t("span",{attrs:{class:"token keyword"}},[e._v("async")]),e._v(" "),t("span",{attrs:{class:"token function"}},[e._v("Init")]),t("span",{attrs:{class:"token punctuation"}},[e._v("(")]),e._v("stub"),t("span",{attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),t("span",{attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),t("span",{attrs:{class:"token comment"}},[e._v("//initialize Chaincode State")]),e._v("\n  "),t("span",{attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n  "),t("span",{attrs:{class:"token keyword"}},[e._v("async")]),e._v(" "),t("span",{attrs:{class:"token function"}},[e._v("Invoke")]),t("span",{attrs:{class:"token punctuation"}},[e._v("(")]),e._v("stub"),t("span",{attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),t("span",{attrs:{class:"token comment"}},[e._v("//Chaincode invokation handler")]),e._v("\n  "),t("span",{attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),t("span",{attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),t("p",[e._v("Listing 8.4.2.1 - Smart Contract Beispiel")]),t("p",[e._v("Die Deploy-Transaktion stellt eine spezielle Form der Invoke-Transaktion dar,\nmit dem zunächst der Smart Contract auf dem jeweiligen Peer instanziiert und\nanschließend die "),t("em",[e._v("Init(...)")]),e._v("-Methode aufgerufen wird. In dieser Methode hat der\nSmart Contract die Gelegenheit die eigenen State-Variablen im Distributed Ledger\nzu initialisieren.\nJede Invoke-Transaktion eines Smart Contracts wird von der Methode "),t("em",[e._v("Invoke(...)")]),e._v("\nbehandelt. Über die Eigenschaften in dem Parameter "),t("em",[e._v("stub")]),e._v(" kann ermittelt werden,\nwelche Funktionen des Smart Contracts mit welche Argumenten aufgerufen wurde, um\ndie gewünschte Aktion vorzunehmen.")]),t("h5",{attrs:{id:"transaktion-workflow"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#transaktion-workflow","aria-hidden":"true"}},[e._v("#")]),e._v(" Transaktion-Workflow")]),t("p",[e._v("Abfragen vom Distributed Ledger werden umgehend vom Peer beantwortet. Für\nAktualisierungen muss der Client eine bestimmte Anzahl von Bestätigungen\n("),t("em",[e._v("Endorsement")]),e._v(") von mehreren Peers einholen. Wie in Abbildung 8.4.2.3\ndargestellt, ruft die Applikation dazu zunächst die gewünschte Funktion im\nSmart Contract auf, wodurch ein Antrag ("),t("em",[e._v("Proposal")]),e._v(") zur Änderung des\nDistributed Ledgers initiiert wird. Die Peers führen dabei die Funktion im\nSmart Contract aus und erzeugen eine signierte Bestätigung des Antrags. Hierbei\nwird der Ledger jedoch noch nicht geändert und lediglich die Bestätigungen der\nPeers erzeugt und an den Client zurück geschickt.")]),t("p",[t("img",{attrs:{src:r(81),alt:"Chaincode Aufruf",title:"Chaincode Aufruf"}})]),t("p",[e._v("Abbildung 8.4.2.3 - Chaincode Aufruf (Quelle: "),t("a",[t("a",{attrs:{href:"#ref_fabr18"}},[e._v("[FABR18]")])]),e._v(")")]),t("p",[e._v("Der Client sammelt die Bestätigungen der einzelnen Peers und überträgt diese\nsamt Antrag an den Ordering Service. Erst mit der Übertragung des Antrags an den\nOrdering Service, wird der Änderungsprozess eingeleitet. Der Ordering Service\nsammelt die Anträge von allen Applikationen, verpackt diese in einen Block und\nüberträgt diese schliesslich an alle Peers. Die Peers hängen anschließend den\nBlock an den jeweils lokalen Ledger und aktualisieren den State. Wenn alle Peers\ndie Änderung übernommen haben, wird die Applikation über die Änderung des\nDistributed Ledgers benachrichtigt und die Transaktion damit abgeschlossen.")]),t("h4",{attrs:{id:"sawtooth"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sawtooth","aria-hidden":"true"}},[e._v("#")]),e._v(" Sawtooth")]),t("p",[e._v("Das Sawtooth Framework ist ebenfalls eine "),t("em",[e._v("permissioned")]),e._v(" Blockchain Plattform,\nfür die Entwicklung von Distributed Ledger Applikationen im Unternehmensumfeld.\nAuch wenn diese Blockchain Plattform ohne Berechtigungen betrieben werden kann,\nso sind die derzeit verfügbaren Konsens-Algorithmen nur für Netzwerke ausgelegt,\nin dem ein gewisses Vertrauen an die Teilnehmer vorausgesetzt wird.")]),t("p",[e._v("Wie in Abbildung 8.4.2.4 dargestellt, besteht das Netzwerk aus Peers\n("),t("em",[e._v("Validator")]),e._v("), einer optionalen REST-Schnittstelle für die Client-Applikationen\nund den optionalen Transaction-Processoren.")]),t("p",[t("img",{attrs:{src:r(80),alt:"Sawtooth Architektur",title:"Sawtooth Architektur"}})]),t("p",[e._v("Abbildung 8.4.2.4 - Sawtooth Architektur (Quelle: "),t("a",[t("a",{attrs:{href:"#ref_sawt18"}},[e._v("[SAWT18]")])]),e._v(")")]),t("h5",{attrs:{id:"validator"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#validator","aria-hidden":"true"}},[e._v("#")]),e._v(" Validator")]),t("p",[e._v("Der Validator ist zuständig für das Ausführen, Validieren und Verteilen der\nTransaktionen an die restlichen Validatoren. Dazu werden zwei Netzwerk-Ebenen\nverwendet, um zum einen neue Transaktionen mit den benachbarten Peers\nauszutauschen und zum anderen mit den Transaction Processoren zu kommunizieren.\nFür die Kommunikation zwischen den Validatoren, wird das Open-Source Projekt 0MQ\nverwendet.")]),t("h5",{attrs:{id:"transaction-processor"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#transaction-processor","aria-hidden":"true"}},[e._v("#")]),e._v(" Transaction Processor")]),t("p",[e._v("Für die Entwicklung einer Applikation auf Basis des Sawtooth Framworks, muss ein\nsogenannter Transaction Processor implementiert werden. Im Gegensatz zu Smart\nContracts, wird die implementierte Applikation nicht in das Blockchain-Netzwerk\nzur Ausführung auf den Peers ausgeliefert. Stattdessen wird der Transaction\nProcessor eigenständig ausgeführt und registriert sich bei den Peers zur\nVerarbeitung von Transaktionen eines bestimmten Typs ("),t("em",[e._v("Transaction Family")]),e._v(").\nDabei gibt die Client Applikation in der Transaktion an, um welche Typ von\nTransaktion es sich handelt und serialisiert die Applikationsdaten in den\nPayload der Transaktion. Daher kann das Netzwerk an Validatoren als Tunnel\nzwischen dem Client und dem Transaction Processor betrachtet werden,\nwährend der State der Applikation im Distributed Ledger persistiert wird.")]),t("p",[e._v("Daher kann das Netzwerk an Validatoren als Tunnel zwischen dem Client und dem\nTransaction Processor betrachtet werden, während der State der Applikation im\n[Distributed Ledger persistiert wird.\nDurch die Erweiterung Sawtooth-Seth, können Ebenfalls Ethereum kompatible Smart\nContracts in der Sawtooth Blockchain ausgeführt werden.")]),t("h5",{attrs:{id:"rest-schnittstelle"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rest-schnittstelle","aria-hidden":"true"}},[e._v("#")]),e._v(" REST-Schnittstelle")]),t("p",[e._v("Um den Zugriff auf das Blockchain-Netzwerk zu vereinfachen, kann die\nREST-Schnittstelle aus dem Framework verwendet werden. Der REST-Dienst verbindet\nsich mittels 0MQ, mit dem in der Konfiguration festgelegten Validator und stellt\ndie Validator Funktionen über REST-Ressourcen bereit.")]),t("h4",{attrs:{id:"iroha"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#iroha","aria-hidden":"true"}},[e._v("#")]),e._v(" Iroha")]),t("p",[e._v("Das Hyperledger Iroha Framework ist eine "),t("em",[e._v("permissioned")]),e._v(" Blockchain Plattform mit\ndem Fokus digitale Assets, Identitäten und serialisierte Daten in einem\nDistributed Ledger zu verwalten "),t("a",[t("a",{attrs:{href:"#ref_iroh18"}},[e._v("[IROH18]")])]),e._v(".")]),t("p",[e._v("Während Iroha auf dem Fabric Framework basiert, sind im Gegensatz dazu keine\nSmart Contracts möglich "),t("a",[t("a",{attrs:{href:"#ref_maka17"}},[e._v("[MAKA17]")])]),e._v(". Damit beschränkt sich\nder Use-Case für Iroha, in der Verwaltung, Abfrage und dem Transfer von\ndigitalen Objekten innerhalb des Distributed Ledgers. Dazu werden bereits\ngenerierte gRPC Clients für C++, Java, Objective-C, Swift, Python und NodeJS\nbereitgestellt.")]),t("h4",{attrs:{id:"indy-burrow"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#indy-burrow","aria-hidden":"true"}},[e._v("#")]),e._v(" Indy & Burrow")]),t("p",[e._v("Während Hyperledger Indy eine weitere Blockchain Plattform zur Verwaltung von\nIdentitäten darstellt, wird mit dem Burrow Framework die Ausführung von Ethereum\nSmart Contracts (Solidity) auf Basis der Fabric Plattform ermöglicht. Beide\nProjekte befinden sich noch in der Inkubation.")]),t("h3",{attrs:{id:"tools"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tools","aria-hidden":"true"}},[e._v("#")]),e._v(" Tools")]),t("p",[e._v("Neben den Blockchain Plattformen, gehören auch diverse Tools rund um das Thema\nDistributed Ledger zum Hyperledger Projekt. So kann beispielsweise mit dem Tool\n"),t("em",[e._v("Caliper")]),e._v(", die Performance der Blockchain Plattform gemessen. Während diese\nTools eher in die Kategorie Administration eingeordnet werden können, bietet\nfolgendes Entwicklungswerkzeug Unterstützung bei der Entwicklung von Distributed\nLedger Applikationen.")]),t("h4",{attrs:{id:"composer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#composer","aria-hidden":"true"}},[e._v("#")]),e._v(" Composer")]),t("p",[e._v("Das als Webapplikation ausgelegte Entwicklungswerkzeuge Composer, bietet die\nMöglichkeit Distributed Ledger Applikationen für das Fabric Framework zu\nentwickeln. Dabei werden die Funktionalitäten von Fabric gekapselt und dem\nBenutzer eine auf folgende Schablonen reduzierte Umgebung bereitgestellt.")]),t("ul",[t("li",[t("p",[t("strong",[e._v("Model File")]),e._v(" Mit dieser Schablonen können Daten modelliert werden,\ndie im Distributed Ledger abgelegt werden sollen.")])]),t("li",[t("p",[t("strong",[e._v("Script File")]),e._v(" Mittels Javascript kann mit dieser Schablone die Applikations-\nund Business-Logik implementiert werden.")])]),t("li",[t("p",[t("strong",[e._v("Query File")]),e._v(" Eine SQL ähnliche Abfrage Sprache, um unter Verwendung der\nModels, Abfragen gegen den Distributed Ledger zu formulieren.")])]),t("li",[t("p",[t("strong",[e._v("Access Control File")]),e._v(" Definiert welche Rollen und Benutzer Zugriff auf\nwelche Daten dieser Applikation im Distributed Ledger haben.")])])]),t("p",[e._v("Diese Schablonen werden im Anschluss in ein "),t("em",[e._v("Business Network Archiv")]),e._v(" gebündelt\nund können als Chaincode in die Fabric Blockchain deployed werden. Zusätzlich\nkann aus dieser eine Client-Bibliothek generiert werden, um den Zugriff auf die\nFunktionen in dem Chaincode zu ermöglichen.")]),t("h2",{attrs:{id:"ethereum"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ethereum","aria-hidden":"true"}},[e._v("#")]),e._v(" Ethereum")]),t("p",[e._v("Autor: Philipp Möller")]),t("p",[e._v("Testing, Verifikation, etc.")]),t("p",[e._v("Tools (Truffle, etc.)")]),t("h2",{attrs:{id:"literaturverzeichnis"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#literaturverzeichnis","aria-hidden":"true"}},[e._v("#")]),e._v(" Literaturverzeichnis")]),t("p",[t("a",{attrs:{name:"ref_andr18"}},[e._v("[ANDR18]")]),e._v(": Androulaki, Elli, et al. Hyperledger fabric: a distributed operating system for permissioned blockchains. arXiv preprint arXiv:1801.10228, 2018")]),t("p",[t("a",{attrs:{name:"ref_aubl13"}},[e._v("[AUBL13]")]),e._v(": P. L. Aublin, et al.: RBFT: Redundant Byzantine Fault Tolerance. 2013 IEEE 33rd International Conference on Distributed Computing Systems, Philadelphia, 2013, URL: "),t("a",[t("a",{attrs:{href:"http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6681599&isnumber=6681559",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6681599&isnumber=6681559")])])]),t("p",[t("a",{attrs:{name:"ref_cach16"}},[e._v("[CHAC16]")]),e._v(": Cachin, Christian: Architecture of the Hyperledger Blockchain Fabric. Workshop on Distributed Cryptocurrencies and Consensus Ledgers, 2016")]),t("p",[t("a",{attrs:{name:"ref_fabr18"}},[e._v("[FABR18]")]),e._v(": Fabric Documentation. URL: "),t("a",[t("a",{attrs:{href:"http://hyperledger-fabric.readthedocs.io/en/release-1.1/peers/peers.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://hyperledger-fabric.readthedocs.io/en/release-1.1/peers/peers.html")])])]),t("p",[t("a",{attrs:{name:"ref_iroh18"}},[e._v("[IROH18]")]),e._v(": Iroha Dokumentation. URL: "),t("a",[t("a",{attrs:{href:"http://iroha.readthedocs.io/en/latest/overview.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://iroha.readthedocs.io/en/latest/overview.html")])])]),t("p",[t("a",{attrs:{name:"ref_maka17"}},[e._v("[MAKA17]")]),e._v(": Makato, Takemiya: Design for smart contracts. URL: "),t("a",[t("a",{attrs:{href:"https://github.com/hyperledger/iroha/issues/249",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/hyperledger/iroha/issues/249")])])]),t("p",[t("a",{attrs:{name:"ref_mona15"}},[e._v("[MONA15]")]),e._v(": Monaco, V.: Time intervals as a Behavioral Biometric, 2015")]),t("p",[t("a",{attrs:{name:"ref_naka08"}},[e._v("[NAKA08]")]),e._v(": Nakamoto, S., Bitcoin: A peer-to-peer electronic cash system., 2008")]),t("p",[t("a",{attrs:{name:"ref_owen17"}},[e._v("[OWEN17]")]),e._v(": Owens, Luke: Cryptoasset Framework on Intel's Hyperledger Sawtooth. URL: "),t("a",[t("a",{attrs:{href:"https://fullmetalhealth.com/cryptoasset-framework-intels-hyperledger-sawtooth-part-one/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://fullmetalhealth.com/cryptoasset-framework-intels-hyperledger-sawtooth-part-one/")])])]),t("p",[t("a",{attrs:{name:"ref_sawt18"}},[e._v("[SAWT18]")]),e._v(": Sawtooth Documentation. URL: "),t("a",[t("a",{attrs:{href:"https://sawtooth.hyperledger.org/docs/core/releases/latest/contents.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://sawtooth.hyperledger.org/docs/core/releases/latest/contents.html")])])]),t("p",[t("a",{attrs:{name:"ref_zhen17"}},[e._v("[ZHEN17]")]),e._v(": Z. Zheng, et al.: An Overview of Blockchain Technology: Architecture, Consensus, and Future Trends, 2017 IEEE 6th International Congress on Big Data, 2017")])])}],i=r(0),a=Object(i.a)({},function(){this.$createElement;this._self._c;return this._m(0)},t,!1,null,null,null);n.default=a.exports},80:function(e,n,r){e.exports=r.p+"assets/img/hyperledger_sawtooth_components.fc158827.png"},81:function(e,n,r){e.exports=r.p+"assets/img/peers.diagram.6.546b49d6.png"},82:function(e,n,r){e.exports=r.p+"assets/img/peers.diagram.9.b514cad8.png"},83:function(e,n,r){e.exports=r.p+"assets/img/fabric_arch.08fe07ce.png"},84:function(e,n,r){e.exports=r.p+"assets/img/btc_transaction.ef9538cb.png"}}]);