(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{105:function(e,i,r){"use strict";r.r(i);var t=r(0),n=Object(t.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,i=e.$createElement,r=e._self._c||i;return r("div",{staticClass:"content"},[r("h1",{attrs:{id:"continuous-software-engineering"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#continuous-software-engineering","aria-hidden":"true"}},[e._v("#")]),e._v(" Continuous Software Engineering")]),r("h2",{attrs:{id:"definition"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#definition","aria-hidden":"true"}},[e._v("#")]),e._v(" Definition")]),r("p",[e._v('"Continuous Software Engineering" beschreibt eine Möglichkeit der iterativen Softwareentwicklung und fokussiert sich auf den Prozess der Auslieferung an den Benutzer. DAbei wird der agile Softwareentwicklungsprozess unterstützt. Continuous Software Engineering ist interdisziplinär und bezieht im Gegensatz zu reinen agilen Softwareentwicklungsmodellen mehr als die reine Softwareentwicklung mit ein.')]),r("h2",{attrs:{id:"agile-softwareentwicklung"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#agile-softwareentwicklung","aria-hidden":"true"}},[e._v("#")]),e._v(" Agile Softwareentwicklung")]),r("p",[e._v("Agile Softwareentwicklungsprozesse haben zum Ziel, den Prozess der Softwareentwicklung zu beschleunigen und die Zeit bis zum Einsatz beim Benutzer zu verkürzen.")]),r("h3",{attrs:{id:"fruhe-phase-mit-scrum"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fruhe-phase-mit-scrum","aria-hidden":"true"}},[e._v("#")]),e._v(" Frühe Phase mit Scrum")]),r("p",[e._v("Scrum ist eine agile Softwareentwicklungmethode für kleinere Softwareentwicklungsteams. Scrum beschreibt den Softwareentwicklungsprozess, nicht aber den Prozess der Auslieferung an den Nutzer.")]),r("h3",{attrs:{id:"devops"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#devops","aria-hidden":"true"}},[e._v("#")]),e._v(" DevOps")]),r("h5",{attrs:{id:"definition-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#definition-2","aria-hidden":"true"}},[e._v("#")]),e._v(" Definition")]),r("p",[e._v("Anders als  z.b. Scrum beschreibt DevOps nicht den Prozess der Softwareentwicklung, sondern den Prozess der Auslieferung an den Nutzer.")]),r("h5",{attrs:{id:"entwicklung-it-operations"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#entwicklung-it-operations","aria-hidden":"true"}},[e._v("#")]),e._v(" Entwicklung/IT-Operations")]),r("p",[e._v("Der Begriff DevOps setzt sich zusammen aus den Begriffen Development (Entwicklung) und Operations. Der Bereich Entwicklung ist für die Softwareentwicklung zuständig, der Bereich Operations für die notwendige IT-Infrastruktur (z.b. Bereitstellung notwendiger Tools). Wenn zusätzlich der Bereich Sicherheit involviert ist, spricht man auch von DevSecOps. Ziel ist es, dass diese Bereiche enger zusammenarbeiten.")]),r("h5",{attrs:{id:"devops-als-agiler-prozess"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#devops-als-agiler-prozess","aria-hidden":"true"}},[e._v("#")]),e._v(" DevOps als agiler Prozess")]),r("h5",{attrs:{id:"automatisierung"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#automatisierung","aria-hidden":"true"}},[e._v("#")]),e._v(" Automatisierung")]),r("p",[e._v("Ein Ziel von DevOps ist die größtmögliche Automatisierung des Auslieferungsprozesses durch den Einsatz geeigneter Tools. Einfache, repititive Aufgaben werden automatisiert.")]),r("h5",{attrs:{id:"schneller-releases-deployment-cycle"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#schneller-releases-deployment-cycle","aria-hidden":"true"}},[e._v("#")]),e._v(" Schneller Releases/Deployment Cycle")]),r("h5",{attrs:{id:"feedback-bugtracker"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#feedback-bugtracker","aria-hidden":"true"}},[e._v("#")]),e._v(" Feedback (Bugtracker)")]),r("p",[e._v("Um Feedback möglichst schnell zum Entwickler zu bekommen, wird bei DevOps ein Bugtracker verwendet. Der Bugtracker dient dazu, Feedback von Testern zu sammeln, sodass der Entwickler die Möglichkeit hat, zeitnah auf Feedback einzugehen und eventuell gefundene Probleme zu beheben.")]),r("h5",{attrs:{id:"microservices"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#microservices","aria-hidden":"true"}},[e._v("#")]),e._v(" Microservices")]),r("h5",{attrs:{id:"automatisiertes-testen"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#automatisiertes-testen","aria-hidden":"true"}},[e._v("#")]),e._v(" Automatisiertes Testen")]),r("p",[e._v("Soweit möglich, wird bei DevOps automatisiert, bspw. mithilfe von Unit-Tsts, getestet. Jedesmal wenn aus dem Quellccode ein neuer Build erstellt wird, werden automatisierten Tests ausgeführt und deren Ergebnisse an den Entwickler weitergeleitet.")]),r("h2",{attrs:{id:"workflows"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#workflows","aria-hidden":"true"}},[e._v("#")]),e._v(" Workflows")]),r("pre",[r("code",[e._v("Continuous Delivery\n\tContinuous Integration\n\tschnellerer Release\n\tDeployment-Pipeline\n\tjede Version (auch intern) muss lauffähig sein\n\tautomatisierte und manuelle Tests\nContinuous Improvment\n\tkontinuirliche Verbesserung\n\tMöglichkeiten zur Verbesserung werden identifiziert und umgesetzt\nContinuous Integration\n\tContinuous Delivery als Weiterentwicklung\n\nDefinition und Abgrenzung\n")])]),r("h2",{attrs:{id:"tools"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tools","aria-hidden":"true"}},[e._v("#")]),e._v(" Tools")]),r("h3",{attrs:{id:"docker"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#docker","aria-hidden":"true"}},[e._v("#")]),e._v(" Docker")]),r("h4",{attrs:{id:"definition-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#definition-3","aria-hidden":"true"}},[e._v("#")]),e._v(" Definition")]),r("p",[e._v("Docker ist ein Tool zur Containerisierung von Software. Dabei wird die Software mit allen ihren Abhängigkeiten (z.b. Bibliotheken) in ein Image gepackt. Dieses Image kann dann von einem standardisierten Container ausgeführt werden.")]),r("p",[e._v("Die Docker-Laufzeitumgebung ist an Linux angelehnt. Es stehen dem Entwickler somit alle die Funktionen von Linux zur Verfügung. Docker selbst ist ebenfalls Linux-Software und damit standardmäßig nur unter Linux lauffähig. Soll Docker unter Windows oder Mac OS ausgeführt werden, muss ein Linux-System in einer virtuellen Maschine genutzt werden. Docker selbst ist keine Virtualisierunganwendung.")]),r("h4",{attrs:{id:"begriffe"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#begriffe","aria-hidden":"true"}},[e._v("#")]),e._v(" Begriffe")]),r("h5",{attrs:{id:"image"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#image","aria-hidden":"true"}},[e._v("#")]),e._v(" Image")]),r("p",[e._v("Ein Image ist ein Abbild der Software mit ihren Abhängigkeiten.")]),r("h5",{attrs:{id:"layer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#layer","aria-hidden":"true"}},[e._v("#")]),e._v(" Layer")]),r("p",[e._v("Ein Layer ist ein Set von Änderungen innerhalb eines Image. Für jede Änderung wird im Image ein neues Layer angelegt.")]),r("h5",{attrs:{id:"container"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#container","aria-hidden":"true"}},[e._v("#")]),e._v(" Container")]),r("p",[e._v("Ein Container ist die laufende Instanz eines Images. Container bieten eine standardisierte Laufzeitumgebung für Images.")]),r("h4",{attrs:{id:"containerisierung-vs-virtualisierung"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#containerisierung-vs-virtualisierung","aria-hidden":"true"}},[e._v("#")]),e._v(" Containerisierung vs. Virtualisierung")]),r("p",[e._v("Ähnlich wie bei der Virtualisierung wird auch bei der Containerisierung eine Gast-Betriebssystem innerhalb des Host-Systems emuliert, Containerisierung hat gegenüber der Virtualisierung aber den Unterschied, dass das Container-System sich Ressourcen mit dem Host-System teilt. Dies soll bei der Virtualisierung vermieden werden.")]),r("p",[e._v('Im Falle der Containerisierung hat das zum Vorteil, das Ressourcen besser genutzt werden und der "Overhead" einer containerisierten Anwendung sehr viel geringer ist als der einer virtualisierten Anweundung. Dies erlaubt dem Entwickler, problems mehrere containerisierte Anwendungen gleichzeitig laufen zu lassen, was bei der Virtualisierung oft nicht ohne weiteres möglich ist. Docker ist kein System zur Virtualisierung, sondern zur Containerisierung.')]),r("h4",{attrs:{id:"tools-fur-docker"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tools-fur-docker","aria-hidden":"true"}},[e._v("#")]),e._v(" Tools für Docker")]),r("h5",{attrs:{id:"docker-hub"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#docker-hub","aria-hidden":"true"}},[e._v("#")]),e._v(" Docker-Hub")]),r("p",[e._v("Docker-Hub ist ein zentrales Repository für vorkonfigurierte Docker-Container.")]),r("h4",{attrs:{id:"versionsverwaltung"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#versionsverwaltung","aria-hidden":"true"}},[e._v("#")]),e._v(" Versionsverwaltung")]),r("p",[e._v("Docker hat eine integrierte Versionsverwaltung. Änderungen an einem Image werden innerhalb des Image in Form von Layern gespeichert. Mithilfe der Layer lässt sich die komplette Versionshistorie eines Image nachvollziehen.")]),r("h4",{attrs:{id:"sicherheit"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#sicherheit","aria-hidden":"true"}},[e._v("#")]),e._v(" Sicherheit")]),r("p",[e._v("Die Docker-Laufzeitumgebung läuft mit "),r("em",[e._v("root")]),e._v("-Rechten, um Zugriff auf sämtliche Betriebssystem-Funktionen zu haben. Die Ressourcen der Anwendung im Container werden allerdings vom Betriebssystem getrennt, und Docker schränkt den Zugriff auf wichtige Systemdateien ein.")]),r("h3",{attrs:{id:"jira"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#jira","aria-hidden":"true"}},[e._v("#")]),e._v(" JIRA")]),r("h3",{attrs:{id:"jenkins"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#jenkins","aria-hidden":"true"}},[e._v("#")]),e._v(" Jenkins")])])}],!1,null,null,null);i.default=n.exports}}]);